From ef06de62981da2e102eac95c664647c376862e7e Mon Sep 17 00:00:00 2001
From: Piotr Gorski <lucjan.lucjanov@gmail.com>
Date: Mon, 18 Mar 2024 09:18:22 +0100
Subject: [PATCH] pacman: add CachyOS branding

Signed-off-by: Piotr Gorski <lucjan.lucjanov@gmail.com>
---
 doc/makepkg.8.asciidoc                        |   4 +
 doc/makepkg.conf.5.asciidoc                   |   5 +
 etc/makepkg.conf.in                           |   2 +
 lib/libalpm/add.c                             |   7 +
 lib/libalpm/alpm.h                            |  12 +
 lib/libalpm/be_local.c                        |  13 +
 lib/libalpm/cpu_capabilities.c                | 184 +++++++
 lib/libalpm/meson.build                       |   1 +
 lib/libalpm/package.c                         |  11 +
 lib/libalpm/package.h                         |   2 +
 lib/libalpm/sync.c                            |   7 +
 meson.build                                   |   2 +-
 .../integrity/generate_signature.sh.in        |   7 +
 scripts/libmakepkg/lint_config/variable.sh.in |   2 +-
 scripts/libmakepkg/lint_pkgbuild/arch.sh.in   |   1 +
 scripts/libmakepkg/util/config.sh.in          |   2 +-
 scripts/makepkg.sh.in                         |  12 +
 src/common/jsmn.h                             | 471 ++++++++++++++++++
 src/pacman/conf.c                             |  20 +-
 src/pacman/meson.build                        |   1 +
 src/pacman/package.c                          |   6 +
 src/pacman/po/de.po                           |   5 +
 src/pacman/po/pacman.pot                      |   5 +
 src/pacman/po/pl.po                           |   5 +
 src/pacman/po/ru.po                           |   5 +
 src/pacman/sync.c                             |   6 +
 src/pacman/update-notice.c                    | 264 ++++++++++
 src/pacman/update-notice.h                    |  26 +
 28 files changed, 1078 insertions(+), 10 deletions(-)
 create mode 100644 lib/libalpm/cpu_capabilities.c
 create mode 100644 src/common/jsmn.h
 create mode 100644 src/pacman/update-notice.c
 create mode 100644 src/pacman/update-notice.h

diff --git a/doc/makepkg.8.asciidoc b/doc/makepkg.8.asciidoc
index cf819b9..f4ec749 100644
--- a/doc/makepkg.8.asciidoc
+++ b/doc/makepkg.8.asciidoc
@@ -274,6 +274,10 @@ Environment Variables
 	Force build for a specific architecture. Useful for cross-compiling.
 	Overrides the corresponding value defined in linkman:makepkg.conf[5].
 
+**PACKAGECARCH=**"(x86_64|x86_64_v3)"::
+	Force package to be packaged for a specific architecture.
+	Overrides the corresponding value defined in linkman:makepkg.conf[5].
+
 **PKGEXT=**".pkg.tar.gz", **SRCEXT=**".src.tar.gz"::
 	Sets the compression used when making compiled or source packages.
 	Overrides the corresponding value defined in linkman:makepkg.conf[5].
diff --git a/doc/makepkg.conf.5.asciidoc b/doc/makepkg.conf.5.asciidoc
index a7c6f7b..1c21d08 100644
--- a/doc/makepkg.conf.5.asciidoc
+++ b/doc/makepkg.conf.5.asciidoc
@@ -59,6 +59,11 @@ Options
 	A string such as ``i686-pc-linux-gnu''; do not touch this unless you know what
 	you are doing. This can be commented out by most users if desired.
 
+**PACKAGECARCH=**"packagecarch"::
+	Specifies extended computer architecture; possible values include such things
+	as ``x86_64_v2'', ``x86_64_v3'', ``x86_64_v4'', etc. This can be commented
+	out by most users if desired.
+
 **CPPFLAGS=**"cppflags"::
 	Flags used for the C preprocessor; see CFLAGS for more information.
 
diff --git a/etc/makepkg.conf.in b/etc/makepkg.conf.in
index 0a9c05e..76ee841 100644
--- a/etc/makepkg.conf.in
+++ b/etc/makepkg.conf.in
@@ -35,6 +35,8 @@ VCSCLIENTS=('bzr::breezy'
 #
 CARCH="@CARCH@"
 CHOST="@CHOST@"
+#-- That will be applied only at the package() stage.
+PACKAGECARCH="@CARCH@"
 
 #-- Compiler and Linker Flags
 #CPPFLAGS=""
diff --git a/lib/libalpm/add.c b/lib/libalpm/add.c
index 6d245ba..c1792c5 100644
--- a/lib/libalpm/add.c
+++ b/lib/libalpm/add.c
@@ -69,6 +69,13 @@ int SYMEXPORT alpm_add_pkg(alpm_handle_t *handle, alpm_pkg_t *pkg)
 	pkgver = pkg->version;
 
 	_alpm_log(handle, ALPM_LOG_DEBUG, "adding package '%s'\n", pkgname);
+	const char* pkg_db_name = alpm_db_get_name(alpm_pkg_get_db(pkg));
+	if(pkg_db_name != NULL) {
+		if(pkg->installed_db != NULL) {
+			free(pkg->installed_db);
+		}
+		pkg->installed_db = strdup(pkg_db_name);
+	}
 
 	if((dup = alpm_pkg_find(trans->add, pkgname))) {
 		if(dup == pkg) {
diff --git a/lib/libalpm/alpm.h b/lib/libalpm/alpm.h
index e7fc7bb..2f05393 100644
--- a/lib/libalpm/alpm.h
+++ b/lib/libalpm/alpm.h
@@ -2109,6 +2109,13 @@ int alpm_option_remove_assumeinstalled(alpm_handle_t *handle, const alpm_depend_
  * @{
  */
 
+
+/** Returns the allowed physical architectures.
+ * @param handle the context handle
+ * @return the list of physical architectures (caller is responsible for alpm_list_free)
+ */
+alpm_list_t *alpm_option_get_physical_architectures(alpm_handle_t *handle);
+
 /** Returns the allowed package architecture.
  * @param handle the context handle
  * @return the configured package architectures
@@ -2461,6 +2468,11 @@ const char *alpm_pkg_get_version(alpm_pkg_t *pkg);
  */
 alpm_pkgfrom_t alpm_pkg_get_origin(alpm_pkg_t *pkg);
 
+/** Returns the installed db of the package.
+ * @return an alpm_pkgfrom_t constant, -1 on error
+ */
+const char* alpm_pkg_get_installed_db(alpm_pkg_t *pkg);
+
 /** Returns the package description.
  * @param pkg a pointer to package
  * @return a reference to an internal string
diff --git a/lib/libalpm/be_local.c b/lib/libalpm/be_local.c
index 80b0e9d..2702111 100644
--- a/lib/libalpm/be_local.c
+++ b/lib/libalpm/be_local.c
@@ -201,6 +201,12 @@ static alpm_list_t *_cache_get_xdata(alpm_pkg_t *pkg)
 	return pkg->xdata;
 }
 
+static const char *_cache_get_installed_db(alpm_pkg_t *pkg)
+{
+	LAZY_LOAD(INFRQ_DESC);
+	return pkg->installed_db;
+}
+
 /**
  * Open a package changelog for reading. Similar to fopen in functionality,
  * except that the returned 'file stream' is from the database.
@@ -342,6 +348,7 @@ static const struct pkg_operations local_pkg_ops = {
 	.get_isize = _cache_get_isize,
 	.get_reason = _cache_get_reason,
 	.get_validation = _cache_get_validation,
+	.get_installed_db = _cache_get_installed_db,
 	.has_scriptlet = _cache_has_scriptlet,
 	.get_licenses = _cache_get_licenses,
 	.get_groups = _cache_get_groups,
@@ -777,6 +784,8 @@ static int local_db_read(alpm_pkg_t *info, int inforeq)
 				READ_AND_STORE_ALL(info->licenses);
 			} else if(strcmp(line, "%ARCH%") == 0) {
 				READ_AND_STORE(info->arch);
+			} else if(strcmp(line, "%INSTALLED_DB%") == 0) {
+				READ_AND_STORE(info->installed_db);
 			} else if(strcmp(line, "%BUILDDATE%") == 0) {
 				READ_NEXT();
 				info->builddate = _alpm_parsedate(line);
@@ -1018,6 +1027,10 @@ int _alpm_local_db_write(alpm_db_t *db, alpm_pkg_t *info, int inforeq)
 			fprintf(fp, "%%ARCH%%\n"
 							"%s\n\n", info->arch);
 		}
+		if(info->installed_db) {
+			fprintf(fp, "%%INSTALLED_DB%%\n"
+							"%s\n\n", info->installed_db);
+		}
 		if(info->builddate) {
 			fprintf(fp, "%%BUILDDATE%%\n"
 							"%jd\n\n", (intmax_t)info->builddate);
diff --git a/lib/libalpm/cpu_capabilities.c b/lib/libalpm/cpu_capabilities.c
new file mode 100644
index 0000000..94c97a6
--- /dev/null
+++ b/lib/libalpm/cpu_capabilities.c
@@ -0,0 +1,184 @@
+/*
+ *  cpu_capabilities.c
+ *
+ *  Copyright (c) 2022-2023 by Vladislav Nepogodin <vnepogodin@cachyos.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+#include <sys/types.h>
+#include <sys/utsname.h> /* uname */
+
+/* libalpm */
+#include "alpm_list.h"
+#include "log.h"
+#include "util.h"
+
+
+static uint64_t xgetbv(void) {
+#if defined(_MSC_VER)
+  return _xgetbv(0);
+#else
+  uint32_t eax = 0, edx = 0;
+  __asm__ __volatile__("xgetbv\n" : "=a"(eax), "=d"(edx) : "c"(0));
+  return ((uint64_t)edx << 32) | eax;
+#endif
+}
+
+static void cpuid(uint32_t out[4], uint32_t id) {
+#if defined(_MSC_VER)
+  __cpuid((int *)out, id);
+#elif defined(__i386__) || defined(_M_IX86)
+  __asm__ __volatile__("movl %%ebx, %1\n"
+                       "cpuid\n"
+                       "xchgl %1, %%ebx\n"
+                       : "=a"(out[0]), "=r"(out[1]), "=c"(out[2]), "=d"(out[3])
+                       : "a"(id));
+#else
+  __asm__ __volatile__("cpuid\n"
+                       : "=a"(out[0]), "=b"(out[1]), "=c"(out[2]), "=d"(out[3])
+                       : "a"(id));
+#endif
+}
+
+static void cpuidex(uint32_t out[4], uint32_t id, uint32_t sid) {
+#if defined(_MSC_VER)
+  __cpuidex((int *)out, id, sid);
+#elif defined(__i386__) || defined(_M_IX86)
+  __asm__ __volatile__("movl %%ebx, %1\n"
+                       "cpuid\n"
+                       "xchgl %1, %%ebx\n"
+                       : "=a"(out[0]), "=r"(out[1]), "=c"(out[2]), "=d"(out[3])
+                       : "a"(id), "c"(sid));
+#else
+  __asm__ __volatile__("cpuid\n"
+                       : "=a"(out[0]), "=b"(out[1]), "=c"(out[2]), "=d"(out[3])
+                       : "a"(id), "c"(sid));
+#endif
+}
+
+enum cpu_feature {
+  SSE2 = 1 << 0,
+  SSSE3 = 1 << 1,
+  SSE41 = 1 << 2,
+  SSE42 = 1 << 3,
+  AVX = 1 << 4,
+  AVX2 = 1 << 5,
+  AVX512F = 1 << 6,
+  AVX512BW = 1 << 7,
+  AVX512CD = 1 << 8,
+  AVX512DQ = 1 << 9,
+  AVX512VL = 1 << 10,
+  /* ... */
+  UNDEFINED = 1 << 30
+};
+
+static enum cpu_feature g_cpu_features = UNDEFINED;
+
+static enum cpu_feature get_cpu_features(void) {
+  if (g_cpu_features != UNDEFINED) {
+    return g_cpu_features;
+  }
+#if defined(__x86_64__) || defined(_M_X64) || defined(__i386__) || defined(_M_IX86)
+  uint32_t regs[4] = {0};
+  uint32_t *eax = &regs[0], *ebx = &regs[1], *ecx = &regs[2], *edx = &regs[3];
+  (void)edx;
+  enum cpu_feature features = 0;
+  cpuid(regs, 0);
+  const int max_id = *eax;
+  cpuid(regs, 1);
+#if defined(__amd64__) || defined(_M_X64)
+  features |= SSE2;
+#else
+  if (*edx & (1UL << 26))
+    features |= SSE2;
+#endif
+  if (*ecx & (1UL << 0))
+    features |= SSSE3;
+  if (*ecx & (1UL << 19))
+    features |= SSE41;
+  if (*ecx & (1UL << 20))
+    features |= SSE42;
+
+  if (*ecx & (1UL << 27)) { // OSXSAVE
+    const uint64_t mask = xgetbv();
+    if ((mask & 6) == 6) { // SSE and AVX states
+      if (*ecx & (1UL << 28))
+        features |= AVX;
+      if (max_id >= 7) {
+        cpuidex(regs, 7, 0);
+        if (*ebx & (1UL << 5))
+          features |= AVX2;
+        if ((mask & 224) == 224) { // Opmask, ZMM_Hi256, Hi16_Zmm
+          if (*ebx & (1UL << 31))
+            features |= AVX512VL;
+          if (*ebx & (1UL << 16))
+            features |= AVX512F;
+          if (*ebx & (1UL << 30))
+            features |= AVX512BW;
+          if (*ebx & (1UL << 28))
+            features |= AVX512CD;
+          if (*ebx & (1UL << 17))
+            features |= AVX512DQ;
+        }
+      }
+    }
+  }
+  g_cpu_features = features;
+  return features;
+#else
+  /* How to detect NEON? */
+  return 0;
+#endif
+}
+
+alpm_list_t SYMEXPORT *alpm_option_get_physical_architectures(alpm_handle_t *handle)
+{
+    alpm_list_t *supported_architectures = NULL;
+
+    {
+        struct utsname un;
+        uname(&un);
+
+        supported_architectures = alpm_list_add(supported_architectures, strdup(un.machine));
+    }
+
+    const enum cpu_feature features = get_cpu_features();
+
+    /* Check for x86_64_v2 */
+    const bool supports_v2 = (features & SSSE3) && (features & SSE41) && (features & SSE42);
+    if (supports_v2) {
+        _alpm_log(handle, ALPM_LOG_DEBUG, "cpu supports x86_64_v2\n");
+        supported_architectures = alpm_list_add(supported_architectures, strdup("x86_64_v2"));
+    }
+
+    /* Check for x86_64_v3 */
+    const bool supports_v3 = (supports_v2) && (features & AVX) && (features & AVX2);
+    if (supports_v3) {
+        _alpm_log(handle, ALPM_LOG_DEBUG, "cpu supports x86_64_v3\n");
+        supported_architectures = alpm_list_add(supported_architectures, strdup("x86_64_v3"));
+    }
+    
+    /* Check for x86_64_v4 */
+    const bool supports_v4 = (supports_v3) && (features & AVX512F) && (features & AVX512VL) && (features & AVX512BW) && (features & AVX512CD) && (features & AVX512DQ);
+    if (supports_v4) {
+        _alpm_log(handle, ALPM_LOG_DEBUG, "cpu supports x86_64_v4\n");
+        supported_architectures = alpm_list_add(supported_architectures, strdup("x86_64_v4"));
+    }
+
+    return supported_architectures;
+}
diff --git a/lib/libalpm/meson.build b/lib/libalpm/meson.build
index 607e91a..34c8a4d 100644
--- a/lib/libalpm/meson.build
+++ b/lib/libalpm/meson.build
@@ -8,6 +8,7 @@ libalpm_sources = files('''
   be_package.c
   be_sync.c
   conflict.h conflict.c
+  cpu_capabilities.c
   db.h db.c
   deps.h deps.c
   diskspace.h diskspace.c
diff --git a/lib/libalpm/package.c b/lib/libalpm/package.c
index a294d63..11a859d 100644
--- a/lib/libalpm/package.c
+++ b/lib/libalpm/package.c
@@ -87,6 +87,7 @@ static off_t _pkg_get_isize(alpm_pkg_t *pkg)             { return pkg->isize; }
 static alpm_pkgreason_t _pkg_get_reason(alpm_pkg_t *pkg) { return pkg->reason; }
 static int _pkg_get_validation(alpm_pkg_t *pkg) { return pkg->validation; }
 static int _pkg_has_scriptlet(alpm_pkg_t *pkg)           { return pkg->scriptlet; }
+static const char *_pkg_get_installed_db(alpm_pkg_t *pkg) { return pkg->installed_db; }
 
 static alpm_list_t *_pkg_get_licenses(alpm_pkg_t *pkg)   { return pkg->licenses; }
 static alpm_list_t *_pkg_get_groups(alpm_pkg_t *pkg)     { return pkg->groups; }
@@ -152,6 +153,7 @@ const struct pkg_operations default_pkg_ops = {
 	.get_reason      = _pkg_get_reason,
 	.get_validation  = _pkg_get_validation,
 	.has_scriptlet   = _pkg_has_scriptlet,
+	.get_installed_db = _pkg_get_installed_db,
 
 	.get_licenses    = _pkg_get_licenses,
 	.get_groups      = _pkg_get_groups,
@@ -221,6 +223,13 @@ alpm_pkgfrom_t SYMEXPORT alpm_pkg_get_origin(alpm_pkg_t *pkg)
 	return pkg->origin;
 }
 
+const char SYMEXPORT *alpm_pkg_get_installed_db(alpm_pkg_t *pkg)
+{
+	ASSERT(pkg != NULL, return NULL);
+	pkg->handle->pm_errno = ALPM_ERR_OK;
+	return pkg->ops->get_installed_db(pkg);
+}
+
 const char SYMEXPORT *alpm_pkg_get_desc(alpm_pkg_t *pkg)
 {
 	ASSERT(pkg != NULL, return NULL);
@@ -625,6 +634,7 @@ int _alpm_pkg_dup(alpm_pkg_t *pkg, alpm_pkg_t **new_ptr)
 	STRDUP(newpkg->name, pkg->name, goto cleanup);
 	STRDUP(newpkg->version, pkg->version, goto cleanup);
 	STRDUP(newpkg->desc, pkg->desc, goto cleanup);
+	STRDUP(newpkg->installed_db, pkg->installed_db, goto cleanup);
 	STRDUP(newpkg->url, pkg->url, goto cleanup);
 	newpkg->builddate = pkg->builddate;
 	newpkg->installdate = pkg->installdate;
@@ -722,6 +732,7 @@ void _alpm_pkg_free(alpm_pkg_t *pkg)
 	FREE(pkg->name);
 	FREE(pkg->version);
 	FREE(pkg->desc);
+	FREE(pkg->installed_db);
 	FREE(pkg->url);
 	FREE(pkg->packager);
 	FREE(pkg->md5sum);
diff --git a/lib/libalpm/package.h b/lib/libalpm/package.h
index c210ce1..878a710 100644
--- a/lib/libalpm/package.h
+++ b/lib/libalpm/package.h
@@ -54,6 +54,7 @@ struct pkg_operations {
 	alpm_pkgreason_t (*get_reason) (alpm_pkg_t *);
 	int (*get_validation) (alpm_pkg_t *);
 	int (*has_scriptlet) (alpm_pkg_t *);
+	const char *(*get_installed_db) (alpm_pkg_t *);
 
 	alpm_list_t *(*get_licenses) (alpm_pkg_t *);
 	alpm_list_t *(*get_groups) (alpm_pkg_t *);
@@ -100,6 +101,7 @@ struct _alpm_pkg_t {
 	char *sha256sum;
 	char *base64_sig;
 	char *arch;
+	char *installed_db;
 
 	alpm_time_t builddate;
 	alpm_time_t installdate;
diff --git a/lib/libalpm/sync.c b/lib/libalpm/sync.c
index 1653b4b..e6cf0f2 100644
--- a/lib/libalpm/sync.c
+++ b/lib/libalpm/sync.c
@@ -240,6 +240,12 @@ int SYMEXPORT alpm_sync_sysupgrade(alpm_handle_t *handle, int enable_downgrade)
 				alpm_pkg_t *spkg = _alpm_db_get_pkgfromcache(sdb, lpkg->name);
 				if(spkg) {
 					if(check_literal(handle, lpkg, spkg, enable_downgrade)) {
+						const char* sdb_name = alpm_db_get_name(sdb);
+						if (spkg->installed_db != NULL) {
+							free(spkg->installed_db);
+						}
+
+						spkg->installed_db = (sdb_name) ? strdup(sdb_name) : NULL;
 						trans->add = alpm_list_add(trans->add, spkg);
 					}
 					/* jump to next local package */
@@ -1105,6 +1111,7 @@ static int check_pkg_matches_db(alpm_pkg_t *spkg, alpm_pkg_t *pkgfile)
 	} \
 } while(0)
 
+	pkgfile->installed_db = (spkg->installed_db) ? strdup(spkg->installed_db) : NULL;
 	if(strcmp(spkg->name, pkgfile->name) != 0) {
 		_alpm_log(handle, ALPM_LOG_DEBUG,
 				"internal package name mismatch, expected: '%s', actual: '%s'\n",
diff --git a/meson.build b/meson.build
index 79fc3ef..0acaacf 100644
--- a/meson.build
+++ b/meson.build
@@ -369,7 +369,7 @@ pacman_bin = executable(
   pacman_sources,
   include_directories : includes,
   link_with : [libalpm, libcommon],
-  dependencies : [libarchive],
+  dependencies : [libarchive, libcurl],
   install : true,
 )
 
diff --git a/scripts/libmakepkg/integrity/generate_signature.sh.in b/scripts/libmakepkg/integrity/generate_signature.sh.in
index f0dd742..74bec8a 100644
--- a/scripts/libmakepkg/integrity/generate_signature.sh.in
+++ b/scripts/libmakepkg/integrity/generate_signature.sh.in
@@ -52,6 +52,10 @@ create_package_signatures() {
 	if [[ $SIGNPKG != 'y' ]]; then
 		return 0
 	fi
+
+	local _saved_arch="${CARCH}"
+	[[ "x${PACKAGECARCH}" != "x" ]] && CARCH="${PACKAGECARCH}"
+
 	local pkg pkgarch pkg_file
 	local fullver=$(get_full_version)
 
@@ -74,5 +78,8 @@ create_package_signatures() {
 		fi
 	fi
 
+	# Restore CARCH
+	CARCH="${_saved_arch}"
+
 	return $ret
 }
diff --git a/scripts/libmakepkg/lint_config/variable.sh.in b/scripts/libmakepkg/lint_config/variable.sh.in
index 2bc61b0..b5d5e5a 100644
--- a/scripts/libmakepkg/lint_config/variable.sh.in
+++ b/scripts/libmakepkg/lint_config/variable.sh.in
@@ -32,7 +32,7 @@ lint_config_variables() {
 	local array=(DLAGENTS VCSCLIENTS BUILDENV OPTIONS INTEGRITY_CHECK MAN_DIRS
 	             DOC_DIRS PURGE_TARGETS COMPRESSGZ COMPRESSBZ2 COMPRESSXZ
 	             COMPRESSLRZ COMPRESSLZO COMPRESSZ)
-	local string=(CARCH CHOST CPPFLAGS CFLAGS CXXFLAGS LDFLAGS LTOFLAGS DEBUG_CFLAGS
+	local string=(CARCH CHOST PACKAGECARCH CPPFLAGS CFLAGS CXXFLAGS LDFLAGS LTOFLAGS DEBUG_CFLAGS
 	              DEBUG_CXXFLAGS DISTCC_HOSTS BUILDDIR STRIP_BINARIES STRIP_SHARED
 	              STRIP_STATIC PKGDEST SRCDEST SRCPKGDEST LOGDEST PACKAGER GPGKEY
 	              PKGEXT SRCEXT)
diff --git a/scripts/libmakepkg/lint_pkgbuild/arch.sh.in b/scripts/libmakepkg/lint_pkgbuild/arch.sh.in
index 0573b6e..5a0bdad 100644
--- a/scripts/libmakepkg/lint_pkgbuild/arch.sh.in
+++ b/scripts/libmakepkg/lint_pkgbuild/arch.sh.in
@@ -50,6 +50,7 @@ lint_arch() {
 		fi
 	done
 
+	## TODO(vnepogodin): add aliasing (e.g x86_64_v4 -> x86_64_v3 -> x86_64_v2 -> x86_64).
 	if (( ! IGNOREARCH )) && ! in_array "$CARCH" "${arch[@]}"; then
 		error "$(gettext "%s is not available for the '%s' architecture.")" "$pkgbase" "$CARCH"
 		return 1
diff --git a/scripts/libmakepkg/util/config.sh.in b/scripts/libmakepkg/util/config.sh.in
index e9bb704..de3dda8 100644
--- a/scripts/libmakepkg/util/config.sh.in
+++ b/scripts/libmakepkg/util/config.sh.in
@@ -69,7 +69,7 @@ load_makepkg_config() {
 
 	# preserve environment variables to override makepkg.conf
 	local restore_envvars=$(
-		for var in PKGDEST SRCDEST SRCPKGDEST LOGDEST BUILDDIR PKGEXT SRCEXT GPGKEY PACKAGER CARCH; do
+		for var in PKGDEST SRCDEST SRCPKGDEST LOGDEST BUILDDIR PKGEXT SRCEXT GPGKEY PACKAGER CARCH PACKAGECARCH; do
 			# the output of 'declare -p' results in locally scoped values when used within a function
 			[[ -v $var ]] && printf '%s=%s\n' "$var" "${!var@Q}"
 		done
diff --git a/scripts/makepkg.sh.in b/scripts/makepkg.sh.in
index 2c36681..e53d6c8 100644
--- a/scripts/makepkg.sh.in
+++ b/scripts/makepkg.sh.in
@@ -581,6 +581,9 @@ create_package() {
 		exit $E_MISSING_PKGDIR
 	fi
 
+	local _saved_arch="${CARCH}"
+	[[ "x${PACKAGECARCH}" != "x" ]] && CARCH="${PACKAGECARCH}"
+
 	cd_safe "$pkgdir"
 	msg "$(gettext "Creating package \"%s\"...")" "$pkgname"
 
@@ -629,6 +632,9 @@ create_package() {
 
 	shopt -u -o pipefail
 
+	# Restore CARCH
+	CARCH="${_saved_arch}"
+
 	if (( ret )); then
 		error "$(gettext "Failed to create package file.")"
 		exit $E_PACKAGE_FAILED
@@ -761,6 +767,9 @@ install_package() {
 	(( ASDEPS )) && pkglist+=('--asdeps')
 	(( NEEDED )) && pkglist+=('--needed')
 
+	local _saved_arch="${CARCH}"
+	[[ "x${PACKAGECARCH}" != "x" ]] && CARCH="${PACKAGECARCH}"
+
 	for pkg in ${pkgname[@]}; do
 		fullver=$(get_full_version)
 		pkgarch=$(get_pkg_arch $pkg)
@@ -771,6 +780,9 @@ install_package() {
 		fi
 	done
 
+	# Restore CARCH
+	CARCH="${_saved_arch}"
+
 	if ! run_pacman -U "${pkglist[@]}"; then
 		warning "$(gettext "Failed to install built package(s).")"
 		return $E_INSTALL_FAILED
diff --git a/src/common/jsmn.h b/src/common/jsmn.h
new file mode 100644
index 0000000..8ac14c1
--- /dev/null
+++ b/src/common/jsmn.h
@@ -0,0 +1,471 @@
+/*
+ * MIT License
+ *
+ * Copyright (c) 2010 Serge Zaitsev
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+#ifndef JSMN_H
+#define JSMN_H
+
+#include <stddef.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef JSMN_STATIC
+#define JSMN_API static
+#else
+#define JSMN_API extern
+#endif
+
+/**
+ * JSON type identifier. Basic types are:
+ * 	o Object
+ * 	o Array
+ * 	o String
+ * 	o Other primitive: number, boolean (true/false) or null
+ */
+typedef enum {
+  JSMN_UNDEFINED = 0,
+  JSMN_OBJECT = 1 << 0,
+  JSMN_ARRAY = 1 << 1,
+  JSMN_STRING = 1 << 2,
+  JSMN_PRIMITIVE = 1 << 3
+} jsmntype_t;
+
+enum jsmnerr {
+  /* Not enough tokens were provided */
+  JSMN_ERROR_NOMEM = -1,
+  /* Invalid character inside JSON string */
+  JSMN_ERROR_INVAL = -2,
+  /* The string is not a full JSON packet, more bytes expected */
+  JSMN_ERROR_PART = -3
+};
+
+/**
+ * JSON token description.
+ * type		type (object, array, string etc.)
+ * start	start position in JSON data string
+ * end		end position in JSON data string
+ */
+typedef struct jsmntok {
+  jsmntype_t type;
+  int start;
+  int end;
+  int size;
+#ifdef JSMN_PARENT_LINKS
+  int parent;
+#endif
+} jsmntok_t;
+
+/**
+ * JSON parser. Contains an array of token blocks available. Also stores
+ * the string being parsed now and current position in that string.
+ */
+typedef struct jsmn_parser {
+  unsigned int pos;     /* offset in the JSON string */
+  unsigned int toknext; /* next token to allocate */
+  int toksuper;         /* superior token node, e.g. parent object or array */
+} jsmn_parser;
+
+/**
+ * Create JSON parser over an array of tokens
+ */
+JSMN_API void jsmn_init(jsmn_parser *parser);
+
+/**
+ * Run JSON parser. It parses a JSON data string into and array of tokens, each
+ * describing
+ * a single JSON object.
+ */
+JSMN_API int jsmn_parse(jsmn_parser *parser, const char *js, const size_t len,
+                        jsmntok_t *tokens, const unsigned int num_tokens);
+
+#ifndef JSMN_HEADER
+/**
+ * Allocates a fresh unused token from the token pool.
+ */
+static jsmntok_t *jsmn_alloc_token(jsmn_parser *parser, jsmntok_t *tokens,
+                                   const size_t num_tokens) {
+  jsmntok_t *tok;
+  if (parser->toknext >= num_tokens) {
+    return NULL;
+  }
+  tok = &tokens[parser->toknext++];
+  tok->start = tok->end = -1;
+  tok->size = 0;
+#ifdef JSMN_PARENT_LINKS
+  tok->parent = -1;
+#endif
+  return tok;
+}
+
+/**
+ * Fills token type and boundaries.
+ */
+static void jsmn_fill_token(jsmntok_t *token, const jsmntype_t type,
+                            const int start, const int end) {
+  token->type = type;
+  token->start = start;
+  token->end = end;
+  token->size = 0;
+}
+
+/**
+ * Fills next available token with JSON primitive.
+ */
+static int jsmn_parse_primitive(jsmn_parser *parser, const char *js,
+                                const size_t len, jsmntok_t *tokens,
+                                const size_t num_tokens) {
+  jsmntok_t *token;
+  int start;
+
+  start = parser->pos;
+
+  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
+    switch (js[parser->pos]) {
+#ifndef JSMN_STRICT
+    /* In strict mode primitive must be followed by "," or "}" or "]" */
+    case ':':
+#endif
+    case '\t':
+    case '\r':
+    case '\n':
+    case ' ':
+    case ',':
+    case ']':
+    case '}':
+      goto found;
+    default:
+                   /* to quiet a warning from gcc*/
+      break;
+    }
+    if (js[parser->pos] < 32 || js[parser->pos] >= 127) {
+      parser->pos = start;
+      return JSMN_ERROR_INVAL;
+    }
+  }
+#ifdef JSMN_STRICT
+  /* In strict mode primitive must be followed by a comma/object/array */
+  parser->pos = start;
+  return JSMN_ERROR_PART;
+#endif
+
+found:
+  if (tokens == NULL) {
+    parser->pos--;
+    return 0;
+  }
+  token = jsmn_alloc_token(parser, tokens, num_tokens);
+  if (token == NULL) {
+    parser->pos = start;
+    return JSMN_ERROR_NOMEM;
+  }
+  jsmn_fill_token(token, JSMN_PRIMITIVE, start, parser->pos);
+#ifdef JSMN_PARENT_LINKS
+  token->parent = parser->toksuper;
+#endif
+  parser->pos--;
+  return 0;
+}
+
+/**
+ * Fills next token with JSON string.
+ */
+static int jsmn_parse_string(jsmn_parser *parser, const char *js,
+                             const size_t len, jsmntok_t *tokens,
+                             const size_t num_tokens) {
+  jsmntok_t *token;
+
+  int start = parser->pos;
+  
+  /* Skip starting quote */
+  parser->pos++;
+  
+  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
+    char c = js[parser->pos];
+
+    /* Quote: end of string */
+    if (c == '\"') {
+      if (tokens == NULL) {
+        return 0;
+      }
+      token = jsmn_alloc_token(parser, tokens, num_tokens);
+      if (token == NULL) {
+        parser->pos = start;
+        return JSMN_ERROR_NOMEM;
+      }
+      jsmn_fill_token(token, JSMN_STRING, start + 1, parser->pos);
+#ifdef JSMN_PARENT_LINKS
+      token->parent = parser->toksuper;
+#endif
+      return 0;
+    }
+
+    /* Backslash: Quoted symbol expected */
+    if (c == '\\' && parser->pos + 1 < len) {
+      int i;
+      parser->pos++;
+      switch (js[parser->pos]) {
+      /* Allowed escaped symbols */
+      case '\"':
+      case '/':
+      case '\\':
+      case 'b':
+      case 'f':
+      case 'r':
+      case 'n':
+      case 't':
+        break;
+      /* Allows escaped symbol \uXXXX */
+      case 'u':
+        parser->pos++;
+        for (i = 0; i < 4 && parser->pos < len && js[parser->pos] != '\0';
+             i++) {
+          /* If it isn't a hex character we have an error */
+          if (!((js[parser->pos] >= 48 && js[parser->pos] <= 57) ||   /* 0-9 */
+                (js[parser->pos] >= 65 && js[parser->pos] <= 70) ||   /* A-F */
+                (js[parser->pos] >= 97 && js[parser->pos] <= 102))) { /* a-f */
+            parser->pos = start;
+            return JSMN_ERROR_INVAL;
+          }
+          parser->pos++;
+        }
+        parser->pos--;
+        break;
+      /* Unexpected symbol */
+      default:
+        parser->pos = start;
+        return JSMN_ERROR_INVAL;
+      }
+    }
+  }
+  parser->pos = start;
+  return JSMN_ERROR_PART;
+}
+
+/**
+ * Parse JSON string and fill tokens.
+ */
+JSMN_API int jsmn_parse(jsmn_parser *parser, const char *js, const size_t len,
+                        jsmntok_t *tokens, const unsigned int num_tokens) {
+  int r;
+  int i;
+  jsmntok_t *token;
+  int count = parser->toknext;
+
+  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
+    char c;
+    jsmntype_t type;
+
+    c = js[parser->pos];
+    switch (c) {
+    case '{':
+    case '[':
+      count++;
+      if (tokens == NULL) {
+        break;
+      }
+      token = jsmn_alloc_token(parser, tokens, num_tokens);
+      if (token == NULL) {
+        return JSMN_ERROR_NOMEM;
+      }
+      if (parser->toksuper != -1) {
+        jsmntok_t *t = &tokens[parser->toksuper];
+#ifdef JSMN_STRICT
+        /* In strict mode an object or array can't become a key */
+        if (t->type == JSMN_OBJECT) {
+          return JSMN_ERROR_INVAL;
+        }
+#endif
+        t->size++;
+#ifdef JSMN_PARENT_LINKS
+        token->parent = parser->toksuper;
+#endif
+      }
+      token->type = (c == '{' ? JSMN_OBJECT : JSMN_ARRAY);
+      token->start = parser->pos;
+      parser->toksuper = parser->toknext - 1;
+      break;
+    case '}':
+    case ']':
+      if (tokens == NULL) {
+        break;
+      }
+      type = (c == '}' ? JSMN_OBJECT : JSMN_ARRAY);
+#ifdef JSMN_PARENT_LINKS
+      if (parser->toknext < 1) {
+        return JSMN_ERROR_INVAL;
+      }
+      token = &tokens[parser->toknext - 1];
+      for (;;) {
+        if (token->start != -1 && token->end == -1) {
+          if (token->type != type) {
+            return JSMN_ERROR_INVAL;
+          }
+          token->end = parser->pos + 1;
+          parser->toksuper = token->parent;
+          break;
+        }
+        if (token->parent == -1) {
+          if (token->type != type || parser->toksuper == -1) {
+            return JSMN_ERROR_INVAL;
+          }
+          break;
+        }
+        token = &tokens[token->parent];
+      }
+#else
+      for (i = parser->toknext - 1; i >= 0; i--) {
+        token = &tokens[i];
+        if (token->start != -1 && token->end == -1) {
+          if (token->type != type) {
+            return JSMN_ERROR_INVAL;
+          }
+          parser->toksuper = -1;
+          token->end = parser->pos + 1;
+          break;
+        }
+      }
+      /* Error if unmatched closing bracket */
+      if (i == -1) {
+        return JSMN_ERROR_INVAL;
+      }
+      for (; i >= 0; i--) {
+        token = &tokens[i];
+        if (token->start != -1 && token->end == -1) {
+          parser->toksuper = i;
+          break;
+        }
+      }
+#endif
+      break;
+    case '\"':
+      r = jsmn_parse_string(parser, js, len, tokens, num_tokens);
+      if (r < 0) {
+        return r;
+      }
+      count++;
+      if (parser->toksuper != -1 && tokens != NULL) {
+        tokens[parser->toksuper].size++;
+      }
+      break;
+    case '\t':
+    case '\r':
+    case '\n':
+    case ' ':
+      break;
+    case ':':
+      parser->toksuper = parser->toknext - 1;
+      break;
+    case ',':
+      if (tokens != NULL && parser->toksuper != -1 &&
+          tokens[parser->toksuper].type != JSMN_ARRAY &&
+          tokens[parser->toksuper].type != JSMN_OBJECT) {
+#ifdef JSMN_PARENT_LINKS
+        parser->toksuper = tokens[parser->toksuper].parent;
+#else
+        for (i = parser->toknext - 1; i >= 0; i--) {
+          if (tokens[i].type == JSMN_ARRAY || tokens[i].type == JSMN_OBJECT) {
+            if (tokens[i].start != -1 && tokens[i].end == -1) {
+              parser->toksuper = i;
+              break;
+            }
+          }
+        }
+#endif
+      }
+      break;
+#ifdef JSMN_STRICT
+    /* In strict mode primitives are: numbers and booleans */
+    case '-':
+    case '0':
+    case '1':
+    case '2':
+    case '3':
+    case '4':
+    case '5':
+    case '6':
+    case '7':
+    case '8':
+    case '9':
+    case 't':
+    case 'f':
+    case 'n':
+      /* And they must not be keys of the object */
+      if (tokens != NULL && parser->toksuper != -1) {
+        const jsmntok_t *t = &tokens[parser->toksuper];
+        if (t->type == JSMN_OBJECT ||
+            (t->type == JSMN_STRING && t->size != 0)) {
+          return JSMN_ERROR_INVAL;
+        }
+      }
+#else
+    /* In non-strict mode every unquoted value is a primitive */
+    default:
+#endif
+      r = jsmn_parse_primitive(parser, js, len, tokens, num_tokens);
+      if (r < 0) {
+        return r;
+      }
+      count++;
+      if (parser->toksuper != -1 && tokens != NULL) {
+        tokens[parser->toksuper].size++;
+      }
+      break;
+
+#ifdef JSMN_STRICT
+    /* Unexpected char in strict mode */
+    default:
+      return JSMN_ERROR_INVAL;
+#endif
+    }
+  }
+
+  if (tokens != NULL) {
+    for (i = parser->toknext - 1; i >= 0; i--) {
+      /* Unmatched opened object or array */
+      if (tokens[i].start != -1 && tokens[i].end == -1) {
+        return JSMN_ERROR_PART;
+      }
+    }
+  }
+
+  return count;
+}
+
+/**
+ * Creates a new parser based over a given buffer with an array of tokens
+ * available.
+ */
+JSMN_API void jsmn_init(jsmn_parser *parser) {
+  parser->pos = 0;
+  parser->toknext = 0;
+  parser->toksuper = -1;
+}
+
+#endif /* JSMN_HEADER */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* JSMN_H */
diff --git a/src/pacman/conf.c b/src/pacman/conf.c
index 207ebf7..26d6fa6 100644
--- a/src/pacman/conf.c
+++ b/src/pacman/conf.c
@@ -28,7 +28,6 @@
 #include <string.h> /* strdup */
 #include <sys/stat.h>
 #include <sys/types.h>
-#include <sys/utsname.h> /* uname */
 #include <sys/wait.h>
 #include <unistd.h>
 #include <signal.h>
@@ -401,12 +400,19 @@ cleanup:
 int config_add_architecture(char *arch)
 {
 	if(strcmp(arch, "auto") == 0) {
-		struct utsname un;
-		char *newarch;
-		uname(&un);
-		newarch = strdup(un.machine);
-		free(arch);
-		arch = newarch;
+        free(arch);
+
+        alpm_list_t *physical_arches;
+        physical_arches = alpm_option_get_physical_architectures(config->handle);
+
+	    alpm_list_t *i;
+    	for(i = physical_arches; i; i = alpm_list_next(i)) {
+		    char *physical_arch = i->data;
+	        pm_printf(ALPM_LOG_DEBUG, "config: arch: %s\n", physical_arch);
+	        config->architectures = alpm_list_add(config->architectures, physical_arch);
+        }
+	    alpm_list_free(physical_arches);
+        return 0;
 	}
 
 	pm_printf(ALPM_LOG_DEBUG, "config: arch: %s\n", arch);
diff --git a/src/pacman/meson.build b/src/pacman/meson.build
index 6926f67..67f3449 100644
--- a/src/pacman/meson.build
+++ b/src/pacman/meson.build
@@ -13,6 +13,7 @@ pacman_sources = files('''
   callback.h callback.c
   upgrade.c
   util.h util.c
+  update-notice.h update-notice.c
 '''.split())
 
 pacman_conf_sources = files('''
diff --git a/src/pacman/package.c b/src/pacman/package.c
index b832663..dd12262 100644
--- a/src/pacman/package.c
+++ b/src/pacman/package.c
@@ -64,6 +64,7 @@ enum {
 	T_PROVIDES,
 	T_REPLACES,
 	T_REPOSITORY,
+	T_FROM_DB,
 	T_REQUIRED_BY,
 	T_SHA_256_SUM,
 	T_SIGNATURES,
@@ -118,6 +119,7 @@ static void make_aligned_titles(void)
 	buf[T_PROVIDES] = _("Provides");
 	buf[T_REPLACES] = _("Replaces");
 	buf[T_REPOSITORY] = _("Repository");
+	buf[T_FROM_DB] = _("Installed From");
 	buf[T_REQUIRED_BY] = _("Required By");
 	buf[T_SHA_256_SUM] = _("SHA-256 Sum");
 	buf[T_SIGNATURES] = _("Signatures");
@@ -262,6 +264,10 @@ void dump_pkg_full(alpm_pkg_t *pkg, int extra)
 		string_display(titles[T_REPOSITORY],
 				alpm_db_get_name(alpm_pkg_get_db(pkg)), cols);
 	}
+	if(from == ALPM_PKG_FROM_LOCALDB) {
+		string_display(titles[T_FROM_DB],
+				alpm_pkg_get_installed_db(pkg), cols);
+	}
 	string_display(titles[T_NAME], alpm_pkg_get_name(pkg), cols);
 	string_display(titles[T_VERSION], alpm_pkg_get_version(pkg), cols);
 	string_display(titles[T_DESCRIPTION], alpm_pkg_get_desc(pkg), cols);
diff --git a/src/pacman/po/de.po b/src/pacman/po/de.po
index 6106fc5..971c7d8 100644
--- a/src/pacman/po/de.po
+++ b/src/pacman/po/de.po
@@ -735,6 +735,11 @@ msgstr "Repositorium"
 msgid "Required By"
 msgstr "Benötigt von"
 
+#: src/pacman/package.c:122
+#, c-format
+msgid "Installed From"
+msgstr "Installiert von"
+
 #: src/pacman/package.c:122 src/pacman/package.c:242
 #, c-format
 msgid "SHA-256 Sum"
diff --git a/src/pacman/po/pacman.pot b/src/pacman/po/pacman.pot
index a5116a5..373852a 100644
--- a/src/pacman/po/pacman.pot
+++ b/src/pacman/po/pacman.pot
@@ -673,6 +673,11 @@ msgstr ""
 msgid "Required By"
 msgstr ""
 
+#: src/pacman/package.c:122
+#, c-format
+msgid "Installed From"
+msgstr ""
+
 #: src/pacman/package.c:122 src/pacman/package.c:242
 #, c-format
 msgid "SHA-256 Sum"
diff --git a/src/pacman/po/pl.po b/src/pacman/po/pl.po
index 044e66d..dc4c70d 100644
--- a/src/pacman/po/pl.po
+++ b/src/pacman/po/pl.po
@@ -729,6 +729,11 @@ msgstr "Repozytorium"
 msgid "Required By"
 msgstr "Wymagany przez"
 
+#: src/pacman/package.c:122
+#, c-format
+msgid "Installed From"
+msgstr "Zainstalowano z"
+
 #: src/pacman/package.c:122 src/pacman/package.c:242
 #, c-format
 msgid "SHA-256 Sum"
diff --git a/src/pacman/po/ru.po b/src/pacman/po/ru.po
index e085dc2..87cf347 100644
--- a/src/pacman/po/ru.po
+++ b/src/pacman/po/ru.po
@@ -717,6 +717,11 @@ msgstr "Репозиторий"
 msgid "Required By"
 msgstr "Требуется"
 
+#: src/pacman/package.c:122
+#, c-format
+msgid "Installed From"
+msgstr "Установлен из"
+
 #: src/pacman/package.c:122 src/pacman/package.c:242
 #, c-format
 msgid "SHA-256 Sum"
diff --git a/src/pacman/sync.c b/src/pacman/sync.c
index 95340db..af97e80 100644
--- a/src/pacman/sync.c
+++ b/src/pacman/sync.c
@@ -37,6 +37,7 @@
 #include "package.h"
 #include "callback.h"
 #include "conf.h"
+#include "update-notice.h"
 
 static int unlink_verbose(const char *pathname, int ignore_missing)
 {
@@ -728,6 +729,11 @@ static int sync_trans(alpm_list_t *targets)
 			alpm_logaction(config->handle, PACMAN_CALLER_PREFIX,
 					"starting full system upgrade\n");
 		}
+		if (do_update_notice() == -1) {
+			trans_release();
+			return 1;
+		}
+
 		if(alpm_sync_sysupgrade(config->handle, config->op_s_upgrade >= 2) == -1) {
 			pm_printf(ALPM_LOG_ERROR, "%s\n", alpm_strerror(alpm_errno(config->handle)));
 			trans_release();
diff --git a/src/pacman/update-notice.c b/src/pacman/update-notice.c
new file mode 100644
index 0000000..5a5afb9
--- /dev/null
+++ b/src/pacman/update-notice.c
@@ -0,0 +1,264 @@
+/*
+ *  update-notice.c
+ *
+ *  Copyright (c) 2023 by Vladislav Nepogodin <vnepogodin@cachyos.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h> /* intmax_t */
+#include <string.h>
+#include <errno.h>
+#ifdef HAVE_LIBCURL
+#include <curl/curl.h>
+#endif
+
+#include <alpm.h>
+#include <alpm_list.h>
+
+#define JSMN_STATIC
+#include "jsmn.h"
+
+/* pacman */
+#include "update-notice.h"
+#include "util.h"
+#include "conf.h"
+
+struct url_data {
+    size_t size;
+    char* data;
+};
+
+static size_t write_data(void *ptr, size_t size, size_t nmemb, struct url_data *data) {
+    const size_t index = data->size;
+    const size_t n = (size * nmemb);
+
+    data->size += (size * nmemb);
+
+    char* tmp = realloc(data->data, data->size + 1); /* +1 for '\0' */
+    if (tmp) {
+        data->data = tmp;
+    } else {
+        if(data->data) {
+            free(data->data);
+        }
+        return 0;
+    }
+
+    memcpy((data->data + index), ptr, n);
+    data->data[data->size] = '\0';
+
+    return size * nmemb;
+}
+
+static int write_data_to_file(const char *filepath, const char *content) {
+    FILE *fp = NULL;
+    if((fp = fopen(filepath, "wb")) == NULL) {
+        return -1;
+    }
+
+    const size_t contentLength = strlen(content);
+    fwrite(content, sizeof(char), contentLength, fp);
+    fclose(fp);
+
+    return 0;
+}
+
+static char *read_whole_file(const char* filepath) {
+    FILE *fp = NULL;
+    if((fp = fopen(filepath, "rb")) == NULL) {
+        return NULL;
+    }
+
+    fseek(fp, 0u, SEEK_END);
+    const size_t size = ftell(fp);
+    fseek(fp, 0u, SEEK_SET);
+
+    char *buf = (char *) malloc(size + 1);
+    buf[0] = '\0';
+
+    const size_t read = fread(buf, sizeof(char), size, fp);
+    if (read != size) {
+        return NULL;
+    }
+    fclose(fp);
+
+    buf[size] = '\0';
+    return buf;
+}
+
+static char *handle_url(const char* url) {
+    struct url_data data;
+    data.size = 0;
+    data.data = malloc(4096); /* reasonable size initial buffer */
+    if (data.data == NULL) {
+        return NULL;
+    }
+
+    data.data[0] = '\0';
+
+    CURL *curl = curl_easy_init();
+    if (curl) {
+        curl_easy_setopt(curl, CURLOPT_URL, url);
+        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);
+        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &data);
+        CURLcode res = curl_easy_perform(curl);
+        if(res != CURLE_OK) {
+            free(data.data);
+            return NULL;
+        }
+
+        curl_easy_cleanup(curl);
+
+    }
+    return data.data;
+}
+
+static int jsoneq(const char *json, jsmntok_t *tok, const char *s) {
+  if (tok->type == JSMN_STRING && (int)strlen(s) == tok->end - tok->start &&
+      strncmp(json + tok->start, s, tok->end - tok->start) == 0) {
+    return 0;
+  }
+  return -1;
+}
+
+static int check_cachyos_repos(void) {
+    alpm_list_t* dbs = alpm_get_syncdbs(config->handle);
+    for (alpm_list_t* i = dbs; i; i = i->next) {
+        const char* db_name = alpm_db_get_name(i->data);
+        if(strstr(db_name, "cachyos") != NULL) {
+            return 0;
+        }
+    }
+
+    return -1;
+}
+
+static int retrieve_data_from_json(const char* jsondata, char** msg_id, char** msg_body) {
+    jsmn_parser p;
+    jsmntok_t t[128]; /* We expect no more than 4 tokens */
+
+    jsmn_init(&p);
+    int key_count = jsmn_parse(&p, jsondata, strlen(jsondata), t, sizeof(t) / sizeof(t[0]));
+    if (key_count < 0) {
+        return -1;
+    }
+
+    /* We have empty JSON object -> skip */
+    if (key_count == 0) {
+        return 0;
+    }
+
+    /* Assume the top-level element is an object */
+    if (t[0].type != JSMN_OBJECT) {
+        return -1;
+    }
+
+    /* Loop over all keys of the root object */
+    for (int i = 1; i < key_count; ++i) {
+        if (jsoneq(jsondata, &t[i], "id") == 0) {
+            *msg_id = strndup(jsondata + t[i + 1].start, t[i + 1].end - t[i + 1].start);
+        } else if (jsoneq(jsondata, &t[i], "body") == 0) {
+            *msg_body = strndup(jsondata + t[i + 1].start, t[i + 1].end - t[i + 1].start);
+        }
+    }
+
+    return 0;
+}
+
+static void replace_all_chars(const char *st, const char *subst, char c) {
+    /* find first occurrence of substring */
+    register char *loc = strstr(st, subst);
+    register char *next = loc;
+    while (loc) {
+        *next++ = c;
+        register char *tail = loc + strlen(subst);
+
+        /* find next occurrence of substring */
+        if ((loc = strstr(tail, subst))) {
+            ptrdiff_t copy_len = loc - tail;
+
+            /* move the remaining characters to their new positions */
+            memmove(next, tail, copy_len);
+            next += copy_len;
+        } else {
+            /* copy the remaining tail characters including the null terminator */
+            memmove(next, tail, strlen(tail) + 1);
+        }
+    }
+}
+
+int do_update_notice(void) {
+    /* check if we have cachyos repositories */
+    int ret = check_cachyos_repos();
+    if (ret != 0) {
+        return 0;
+    }
+
+    char* data = handle_url("https://iso-stats.cachyos.org/api/v2/last_update_notice");
+    if (!data) {
+        return 0;
+    }
+    if (strcmp(data, "No notice found") == 0) {
+        return 0;
+    }
+
+    char* msg_id = NULL;
+    char* msg_body = NULL;
+    if (retrieve_data_from_json(data, &msg_id, &msg_body) != 0) {
+        pm_printf(ALPM_LOG_ERROR, _("invalid update notice server response\n"));
+        ret = -1;
+        goto cleanup;
+    }
+
+    char* prev_file_id = NULL;
+    char noticepath[PATH_MAX];
+    snprintf(noticepath, PATH_MAX, "%slocal/CACHY_UPDATE_NOTICE", config->dbpath);
+
+    if (msg_id && (prev_file_id = read_whole_file(noticepath)) != NULL
+        && strcmp(msg_id, prev_file_id) == 0) {
+        free(prev_file_id);
+        goto cleanup;
+    }
+
+    if (msg_body) {
+        /* cover case when we receive multiline message */
+        replace_all_chars(msg_body, "\\n", '\n');
+
+        printf(_("%sUpdate notice: %s%s\n"), config->colstr.warn,
+                            config->colstr.nocolor, msg_body);
+        if (yesno(_("Do you want to continue?")) == 0) {
+            ret = -1;
+            goto cleanup;
+        }
+        if (write_data_to_file(noticepath, msg_id) != 0)  {
+            pm_printf(ALPM_LOG_ERROR, _("could not save notice id: %s\n"), strerror(errno));
+            ret = -1;
+            goto cleanup;
+        }
+    }
+
+cleanup:
+    if (msg_id) {
+        free(msg_id);
+    }
+    if (msg_body) {
+        free(msg_body);
+    }
+    free(data);
+
+    return ret;
+}
diff --git a/src/pacman/update-notice.h b/src/pacman/update-notice.h
new file mode 100644
index 0000000..40cb6dc
--- /dev/null
+++ b/src/pacman/update-notice.h
@@ -0,0 +1,26 @@
+/*
+ *  update-notice.h
+ *
+ *  Copyright (c) 2023 by Vladislav Nepogodin <vnepogodin@cachyos.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef PM_UPDATE_NOTICE_H
+#define PM_UPDATE_NOTICE_H
+
+#include <stdlib.h>
+
+int do_update_notice(void);
+
+#endif /* PM_UPDATE_NOTICE_H */
-- 
2.43.0.232.ge79552d197

