From f28d44e5b2a900b42dd823de67d95ed0f21a2685 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Martin=20Fl=C3=B6ser?= <mgraesslin@kde.org>
Date: Fri, 30 Mar 2018 16:09:04 +0200
Subject: Use XdgShell Unstable V6 in nested wayland platform

Summary:
Changing the creation of the nested window from unstable v5 to v6 in
order to be supported on more compositors and to use KWin's better
supported platform.

Targeting 5.12 as this will help to remove support for unstable v5
from KWayland.

Test Plan: Run a nested KWin/Wayland on KWin/Wayland, everything looked fine

Reviewers: #kwin, #plasma

Subscribers: kwin

Tags: #kwin

Differential Revision: https://phabricator.kde.org/D11806
---
 plugins/platforms/wayland/wayland_backend.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/plugins/platforms/wayland/wayland_backend.cpp b/plugins/platforms/wayland/wayland_backend.cpp
index 1beec17..e06881f 100644
--- a/plugins/platforms/wayland/wayland_backend.cpp
+++ b/plugins/platforms/wayland/wayland_backend.cpp
@@ -525,7 +525,7 @@ void WaylandBackend::createSurface()
         m_seat->setInstallCursor(true);
     }
     // check for xdg shell
-    auto xdgIface = m_registry->interface(Registry::Interface::XdgShellUnstableV5);
+    auto xdgIface = m_registry->interface(Registry::Interface::XdgShellUnstableV6);
     if (xdgIface.name != 0) {
         m_xdgShell = m_registry->createXdgShell(xdgIface.name, xdgIface.version, this);
         if (m_xdgShell && m_xdgShell->isValid()) {
-- 
cgit v0.11.2


From 69afe4d266ffbde364913d31fbcbc00769b4b390 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Martin=20Fl=C3=B6ser?= <mgraesslin@kde.org>
Date: Wed, 2 May 2018 20:47:59 +0200
Subject: Update seat's timestamp after waking up screen through double tap

Summary:
The drm platform has a special handling for touch events while the
screen is in dpms. All touch events are filtered out, but a double
tap wakes up the screen.

Due to the filtering out of the events the idle timers were not reset.
So if you only double tapped, the screen turned on, but not off again.

This change updates the timestamp after double tap, so that the idle
timers are restarted. All other events are still filtered out, to not
have "fake" events (e.g. smart phone in pocket) wake up the device.

BUG: 392754
FIXED-IN: 5.12.6

Test Plan: only compile tested

Reviewers: #kwin, #plasma

Subscribers: kwin

Tags: #kwin

Differential Revision: https://phabricator.kde.org/D12668
---
 plugins/platforms/drm/drm_inputeventfilter.cpp | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/plugins/platforms/drm/drm_inputeventfilter.cpp b/plugins/platforms/drm/drm_inputeventfilter.cpp
index e4ef498..e2625ca 100644
--- a/plugins/platforms/drm/drm_inputeventfilter.cpp
+++ b/plugins/platforms/drm/drm_inputeventfilter.cpp
@@ -19,9 +19,12 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "drm_inputeventfilter.h"
 #include "drm_backend.h"
+#include "wayland_server.h"
 
 #include <QApplication>
 
+#include <KWayland/Server/seat_interface.h>
+
 namespace KWin
 {
 
@@ -82,10 +85,10 @@ bool DpmsInputEventFilter::touchDown(quint32 id, const QPointF &pos, quint32 tim
 
 bool DpmsInputEventFilter::touchUp(quint32 id, quint32 time)
 {
-    Q_UNUSED(time)
     m_touchPoints.removeAll(id);
     if (m_touchPoints.isEmpty() && m_doubleTapTimer.isValid() && m_secondTap) {
         if (m_doubleTapTimer.elapsed() < qApp->doubleClickInterval()) {
+            waylandServer()->seat()->setTimestamp(time);
             notify();
         }
         m_doubleTapTimer.invalidate();
-- 
cgit v0.11.2


From 9a02ed4d360ffa18c3c406ab0eb1d01ccc9c0901 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Martin=20Fl=C3=B6ser?= <mgraesslin@kde.org>
Date: Mon, 7 May 2018 21:59:17 +0200
Subject: Do not save kwinrulesrc on every window opening/closing

Summary:
Our rule handling has had a grave error for years. Whenever a window
with a rule was openend or closed the kwinrulesrc was written back to
disk.

The reason for this behavior is that temporary rules need to be discarded
once they were used. For that there is a method discardUsed which invokes
requestDiskStorage whenever a rule for the window was found. But it did
not check whether there was a rule requiring this.

This change modifies the discardUsed to track whether it changed a rule
and only writes back in case there was a change.

BUG: 393911
FIXED-IN: 5.12.6

Test Plan: Only compile tested

Reviewers: #kwin, #plasma

Subscribers: kwin

Tags: #kwin

Differential Revision: https://phabricator.kde.org/D12749
---
 rules.cpp | 18 +++++++++++++-----
 rules.h   |  2 +-
 2 files changed, 14 insertions(+), 6 deletions(-)

diff --git a/rules.cpp b/rules.cpp
index 031dde3..e728b06 100644
--- a/rules.cpp
+++ b/rules.cpp
@@ -686,17 +686,22 @@ bool Rules::discardTemporary(bool force)
 
 #define DISCARD_USED_SET_RULE( var ) \
     do { \
-        if ( var##rule == ( SetRule ) ApplyNow || ( withdrawn && var##rule == ( SetRule ) ForceTemporarily )) \
+        if ( var##rule == ( SetRule ) ApplyNow || ( withdrawn && var##rule == ( SetRule ) ForceTemporarily )) { \
             var##rule = UnusedSetRule; \
+            changed = true; \
+        } \
     } while ( false )
 #define DISCARD_USED_FORCE_RULE( var ) \
     do { \
-        if ( withdrawn && var##rule == ( ForceRule ) ForceTemporarily ) \
+        if ( withdrawn && var##rule == ( ForceRule ) ForceTemporarily ) { \
             var##rule = UnusedForceRule; \
+            changed = true; \
+        } \
     } while ( false )
 
-void Rules::discardUsed(bool withdrawn)
+bool Rules::discardUsed(bool withdrawn)
 {
+    bool changed = false;
     DISCARD_USED_FORCE_RULE(placement);
     DISCARD_USED_SET_RULE(position);
     DISCARD_USED_SET_RULE(size);
@@ -732,6 +737,8 @@ void Rules::discardUsed(bool withdrawn)
     DISCARD_USED_FORCE_RULE(strictgeometry);
     DISCARD_USED_SET_RULE(shortcut);
     DISCARD_USED_FORCE_RULE(disableglobalshortcuts);
+
+    return changed;
 }
 #undef DISCARD_USED_SET_RULE
 #undef DISCARD_USED_FORCE_RULE
@@ -1115,8 +1122,9 @@ void RuleBook::discardUsed(AbstractClient* c, bool withdrawn)
             it != m_rules.end();
        ) {
         if (c->rules()->contains(*it)) {
-            updated = true;
-            (*it)->discardUsed(withdrawn);
+            if ((*it)->discardUsed(withdrawn)) {
+                updated = true;
+            }
             if ((*it)->isEmpty()) {
                 c->removeRule(*it);
                 Rules* r = *it;
diff --git a/rules.h b/rules.h
index 007ce5b..8ad459d 100644
--- a/rules.h
+++ b/rules.h
@@ -115,7 +115,7 @@ public:
     void write(KConfigGroup&) const;
     bool isEmpty() const;
 #ifndef KCMRULES
-    void discardUsed(bool withdrawn);
+    bool discardUsed(bool withdrawn);
     bool match(const AbstractClient* c) const;
     bool update(AbstractClient*, int selection);
     bool isTemporary() const;
-- 
cgit v0.11.2

