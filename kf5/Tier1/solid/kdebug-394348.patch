From 8e9fc89918c4a8817b624a61e0d2d32d349722cc Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Stefan=20Br=C3=BCns?= <stefan.bruens@rwth-aachen.de>
Date: Mon, 6 Aug 2018 02:21:40 +0200
Subject: Force reevaluation of Predicates if interfaces are removed

Summary:
If an application wants to show only specicific devices based on predicate
matching, and one of the matching devices loses an interface which is
critical for the Predicate to match, the application has to be notified.

As there is no dedicated signal to notify the application about the
fact a device no longer has e.g. a Solid::StorageAccess iface, signal the
device has been removed, and immediately readd it, as the device may
still be relevant.

Remove the call to updateBackend(udi), as the device backend listens to
the InterfacesRemoved signal itself and updates its property cache.

CCBUG: 394348

Test Plan:
1. Image file mounting via loop-back
  - udisksctl loop-setup -f ~/fat.img
  -> Icon appears under "Devices"
  - unmount via context-menu in dolphin
  -> device icon stays in "Devices"
  - set "Auto-clear" flag on loop (e.g. losetup --detach-all)
  - remount
  - unmount
  -> device icon vanishes from "Devices"
2. CD-ROM/DVD
  -  icon appear when a non-blank medium is inserted
  - vanishes on medium removal
3. USB stick
  - for each mountable filesystem, an icon appears under "Removable devices"
  - formatting a partition with a non-mountable filesystem/blank removes the entry
  - formatting with a mountable FS (re)adds the entry

Reviewers: #frameworks, broulik, ngraham, apol

Reviewed By: broulik

Subscribers: apol, anthonyfieroni, kde-frameworks-devel

Tags: #frameworks

Differential Revision: https://phabricator.kde.org/D14661
---
 .../devices/backends/udisks2/udisksmanager.cpp     | 23 +++++++++++++++++++---
 1 file changed, 20 insertions(+), 3 deletions(-)

diff --git a/src/solid/devices/backends/udisks2/udisksmanager.cpp b/src/solid/devices/backends/udisks2/udisksmanager.cpp
index f916720..1783391 100644
--- a/src/solid/devices/backends/udisks2/udisksmanager.cpp
+++ b/src/solid/devices/backends/udisks2/udisksmanager.cpp
@@ -204,6 +204,9 @@ void Manager::slotInterfacesAdded(const QDBusObjectPath &object_path, const Vari
 void Manager::slotInterfacesRemoved(const QDBusObjectPath &object_path, const QStringList &interfaces)
 {
     const QString udi = object_path.path();
+    if (udi.isEmpty()) {
+        return;
+    }
 
     /* Ignore jobs */
     if (udi.startsWith(UD2_DBUS_PATH_JOBS)) {
@@ -212,14 +215,28 @@ void Manager::slotInterfacesRemoved(const QDBusObjectPath &object_path, const QS
 
     qDebug() << udi << "lost interfaces:" << interfaces;
 
-    updateBackend(udi);
-
+    /*
+     * Determine left interfaces. The device backend may have processed the
+     * InterfacesRemoved signal already, but the result set is the same
+     * independent if the backend or the manager processes the signal first.
+     */
     Device device(udi);
+    auto leftInterfaces = device.interfaces().toSet();
+    leftInterfaces.subtract(interfaces.toSet());
 
-    if (!udi.isEmpty() && (interfaces.isEmpty() || device.interfaces().isEmpty())) {
+    if (leftInterfaces.isEmpty()) {
+        // remove the device if the last interface is removed
         emit deviceRemoved(udi);
         m_deviceCache.removeAll(udi);
         DeviceBackend::destroyBackend(udi);
+    } else {
+        /*
+         * Changes in the interface composition may change if a device
+         * matches a Predicate. We have to do a remove-and-readd cycle
+         * as there is no dedicated signal for Predicate reevaluation.
+         */
+        emit deviceRemoved(udi);
+        emit deviceAdded(udi);
     }
 }
 
-- 
cgit v0.11.2

